## Normal Distribution

```{r}
p_value_PRO <- function(mu,sigma,x) {
  p <- (1/(sigma*sqrt(2*pi)))*( exp( (-(x-mu)^2)/(2*sigma^2) ) )
  p
}
p_value_PRO <- p_value_PRO(140, 25,130)
p_value_PRO

erfz <- function(z) {
  erfz <- 1 - (( 1/( (1+0.3275911*z)^4 ))* ( exp(-z^2) ))
  erfz
}
ez <- erfz(z)

#CDF-Harts approximation
my_pnorm_hart <- function(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) {
  # Standardize q
  z <- (q - mean) / sd
  if (z > 6) return(ifelse(log.p, 0, 1)) # Handle extreme cases
  if (z < -6) return(ifelse(log.p, -Inf, 0))
  
  # Constants from Hart's approximation
  b0 <- 0.2316419
  b1 <- 0.319381530
  b2 <- -0.356563782
  b3 <- 1.781477937
  b4 <- -1.821255978
  b5 <- 1.330274429
  
  # Compute approximation
  t <- 1 / (1 + b0 * abs(z))
  poly <- ((((b5 * t + b4) * t + b3) * t + b2) * t + b1) * t
  phi <- (1 / sqrt(2 * pi)) * exp(-0.5 * z^2)
  
  # Compute cumulative probability
  Phi <- ifelse(z >= 0, 1 - phi * poly, phi * poly)
  
  # Handle lower tail and log options
  if (!lower.tail) Phi <- 1 - Phi
  if (log.p) Phi <- log(Phi)
  
  return(Phi)
}

# Testing with your example
z <- (130 - 140) / (25 / sqrt(200))
p_value_R <- 2 * pnorm(-abs(z))   # R's built-in pnorm
p_value_my <- 2 * my_pnorm_hart(-abs(z))  # My Hart's approximation

cat("R's p-value:", p_value_R, "\n")
cat("My p-value:", p_value_my, "\n")

#CDF-Abraham's approximation
my_pnorm <- function(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) {
  # Standardize q
  z <- (q - mean) / sd
  
  # Constants for Abramowitz & Stegun approximation
  a <- c(0.254829592, -0.284496736, 1.421413741, -1.453152027, 1.061405429)
  p <- 0.3275911
  
  # Compute absolute z
  sign_z <- ifelse(z < 0, -1, 1)
  z_abs <- abs(z) / sqrt(2)
  
  # Compute error function approximation (Abramowitz & Stegun 7.1.26)
  t <- 1 / (1 + p * z_abs)
  erf_approx <- 1 - (((((a[5] * t + a[4]) * t) + a[3]) * t + a[2]) * t + a[1]) * t * exp(-z_abs^2)
  
  # Compute Phi(z)
  phi_z <- 0.5 * (1 + sign_z * erf_approx)
  
  # Handle tail cases
  if (!lower.tail) phi_z <- 1 - phi_z
  if (log.p) phi_z <- log(phi_z)
  
  return(phi_z)
}

# Test cases
my_pnorm(-abs(z)) 



```

